package xyz.pixelatedw.mineminenomi.abilities;

import java.io.Serializable;

import java.util.ArrayList;
import java.util.Arrays;
import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.particles.ParticleType;
import net.minecraft.util.DamageSource;
import xyz.pixelatedw.mineminenomi.api.abilities.DamagedPassiveAbility;
import xyz.pixelatedw.mineminenomi.api.helpers.DevilFruitHelper;
import xyz.pixelatedw.mineminenomi.api.helpers.HakiHelper;
import xyz.pixelatedw.mineminenomi.api.helpers.ItemsHelper;
import xyz.pixelatedw.mineminenomi.api.helpers.abilities.AbilityHelper;
import xyz.pixelatedw.mineminenomi.config.CommonConfig;
import xyz.pixelatedw.mineminenomi.data.entity.devilfruit.DevilFruitCapability;
import xyz.pixelatedw.mineminenomi.data.entity.entitystats.EntityStatsCapability;
import xyz.pixelatedw.mineminenomi.init.ModDamageSource;
import xyz.pixelatedw.mineminenomi.init.ModEffects;
import xyz.pixelatedw.mineminenomi.particles.data.GenericParticleData;
import xyz.pixelatedw.mineminenomi.particles.effects.common.LogiaParticleEffect;
import xyz.pixelatedw.mineminenomi.wypi.APIConfig;
import xyz.pixelatedw.mineminenomi.wypi.abilities.Ability;
import xyz.pixelatedw.mineminenomi.wypi.abilities.IChangeDamageSourceAbility;
import xyz.pixelatedw.mineminenomi.wypi.abilities.projectiles.AbilityProjectileEntity;
import xyz.pixelatedw.mineminenomi.wypi.data.ability.AbilityDataCapability;

public class LogiaInvulnerabilityAbility
  extends DamagedPassiveAbility
{
  private final ParticleType<GenericParticleData> particle;
  protected ILogiaEffect onSpecificLogiaEffect = (target, attacker) -> true;
  private final DamageSource[] newSources;
  private final String name;
  public LogiaParticleEffect particleEffect;
  public ArrayList<DamageSource> immunitySources = new ArrayList<>(Arrays.asList(new DamageSource[] { DamageSource.CACTUS, DamageSource.SWEET_BERRY_BUSH, DamageSource.ANVIL, DamageSource.FLY_INTO_WALL, DamageSource.FALL, DamageSource.FALLING_BLOCK, DamageSource.FIREWORKS }));
  private ArrayList<String> acceptableInstantSources = new ArrayList<>(Arrays.asList(new String[] { "mob", "player" }));
  private LogiaParticleEffect fireLogiaParticleEffect = null;

  
  public LogiaInvulnerabilityAbility(ParticleType<GenericParticleData> particle, String name, ILogiaEffect effect, DamageSource... sources) {
    super("Logia Invulnerability " + name, AbilityHelper.getDevilFruitCategory());
    setDescription("Allows the user to avoid attacks by instinctively transforming parts of their body into their specific element");
    this.particle = particle;
    this.name = name;
    this.newSources = sources;
    this.immunitySources.addAll(Arrays.asList(this.newSources));
    this.onDamagedEvent = this::onDamagedEvent;
    if (effect != null)
      this.onSpecificLogiaEffect = effect; 
    this.particleEffect = new LogiaParticleEffect(this.particle);
    hideInGUI(false);
    setDisplayName("Logia Invulnerability");
  }


  
  public boolean onDamagedEvent(LivingEntity entity, DamageSource damageSource) {
    if (!((Boolean)CommonConfig.INSTANCE.logiaInvulnerability.get()).booleanValue() || 
      !DevilFruitCapability.get(entity).isLogia() || entity
      .isPotionActive(ModEffects.ABILITY_OFF) || 
      DevilFruitHelper.kairosekiChecks(entity) || (damageSource instanceof ModDamageSource && ((ModDamageSource)damageSource)
      .isDamageBypassingLogiaInvulnerability()))
    {
      
      return true;
    }

    
    boolean hasShadow = EntityStatsCapability.get(entity).hasShadow();
    if (this.immunitySources.contains(DamageSource.ON_FIRE) && damageSource == DamageSource.ON_FIRE && !hasShadow) {
      return true;
    }
    if (damageSource.isExplosion()) {
      
      spawnParticles((Entity)entity, false);
      return false;
    } 
    
    boolean result = true;
    Entity trueSource = damageSource.getTrueSource();
    Entity instantSource = damageSource.getImmediateSource();
    
    if (instantSource instanceof LivingEntity && this.acceptableInstantSources.contains(damageSource.getDamageType())) {
      
      result = false;
      
      boolean isUsingChangeDamageSource = Arrays.<Ability>stream(AbilityDataCapability.get((LivingEntity)instantSource).getEquippedAbilities(APIConfig.AbilityCategory.ALL)).anyMatch(ability -> (ability instanceof IChangeDamageSourceAbility && ((IChangeDamageSourceAbility)ability).isSourceChangeEnabled()));
      
      if (!isUsingChangeDamageSource) {
        
        result = this.onSpecificLogiaEffect.attackerEffect(entity, (LivingEntity)instantSource);
        
        ItemStack heldItem = ((LivingEntity)instantSource).getHeldItemMainhand();
        
        boolean hasHardeningHaki = (heldItem.isEmpty() && HakiHelper.hasHardeningActive((LivingEntity)instantSource));
        boolean hasImbuingHaki = (!heldItem.isEmpty() && HakiHelper.hasImbuingActive((LivingEntity)instantSource));
        boolean hasKairosekiWeapon = ItemsHelper.isKairosekiWeapon(heldItem);
        
        boolean bypassInvulnerability = (hasHardeningHaki || hasImbuingHaki || hasKairosekiWeapon);
        
        if (bypassInvulnerability) {
          return true;
        }
      } 
    } 
    if (damageSource.isProjectile()) {
      
      result = instantSource instanceof xyz.pixelatedw.mineminenomi.entities.projectiles.extra.KairosekiBulletProjectile;
      
      if (instantSource instanceof AbilityProjectileEntity && trueSource instanceof LivingEntity)
      {
        if (CommonConfig.INSTANCE.doLogiasHaveHurtHakiLogic()) {
          
          AbilityProjectileEntity projectileEntity = (AbilityProjectileEntity)instantSource;
          if (projectileEntity.isPhysical()) {
            
            if (projectileEntity.isAffectedByHardening() && HakiHelper.hasHardeningActive((LivingEntity)trueSource)) {
              result = true;
            } else if (projectileEntity.isAffectedByImbuing() && HakiHelper.hasImbuingActive((LivingEntity)trueSource)) {
              result = true;
            } 
          } else {
            result = CommonConfig.INSTANCE.doLogiasHaveHurtExtendedLogic();
          } 
        } 
      }
    } 
    
    if (this.immunitySources.stream().anyMatch(s -> damageSource.getDamageType().equals(s.getDamageType()))) {
      result = false;
    }
    
    boolean fireResistance = (this.immunitySources.stream().anyMatch(s -> s.getDamageType().equals("inFire")) && (damageSource.getDamageType().equals("inFire") || damageSource.getDamageType().equals("onFire")));
    boolean magmaImmunity = (this.immunitySources.stream().anyMatch(s -> s.getDamageType().equals("lava")) && damageSource.isFireDamage());
    
    boolean spawnFireParticles = false;
    if (fireResistance || magmaImmunity) {
      
      entity.extinguish();
      
      if (result && CommonConfig.INSTANCE.doLogiasHaveHurtExtendedLogic() && instantSource instanceof AbilityProjectileEntity) {
        return true;
      }
      spawnFireParticles = true;
      result = false;
    } 
    
    if (!result) {
      spawnParticles((Entity)entity, spawnFireParticles);
    }
    return result;
  }

  
  public void spawnParticles(Entity entity, boolean isFire) {
    if (isFire) {
      
      if (this.fireLogiaParticleEffect == null)
        this.fireLogiaParticleEffect = new LogiaParticleEffect(this.particle); 
      this.fireLogiaParticleEffect.ownerID = entity.getEntityId();
      this.fireLogiaParticleEffect.hideTooClose = true;
      this.fireLogiaParticleEffect.spawn(entity.world, entity.getPosX(), entity.getPosY(), entity.getPosZ(), 0.0D, 0.0D, 0.0D);
    }
    else {
      
      this.particleEffect.spawn(entity.world, entity.getPosX(), entity.getPosY(), entity.getPosZ(), 0.0D, 0.0D, 0.0D);
    } 
  }



  
  public Ability create() {
    try {
      return getClass().getConstructor(new Class[] { ParticleType.class, String.class, ILogiaEffect.class, DamageSource[].class }).newInstance(new Object[] { this.particle, this.name, this.onSpecificLogiaEffect, this.newSources });
    }
    catch (Exception ex) {
      
      ex.printStackTrace();
      
      return null;
    } 
  }
  
  public static interface ILogiaEffect extends Serializable {
    boolean attackerEffect(LivingEntity param1LivingEntity1, LivingEntity param1LivingEntity2);
  }
}


